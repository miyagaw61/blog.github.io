TWCTF2017に出ました。  
楽しかったです。ありがとうございました。  
今回は珍しくIPFactoryではなく、勉強会やセキュリティキャンプ、Twitterなどで知り合った仲の良い学生達が集まった少数チームで出場しました。  
総合で解いた問題は、Welcome!, Just do it!, Rev Rev Rev, Freshen Uploader, Palindromes Pairs - Coding Phase - , My Simple Cipher, pplc, BabyDLPの8問です。  
僕が実際に解いたのはjust do itのみで、後は激ムズpwn問2つ（swap, simple note）とずっと戦っていました。  
  
swapは、入力値二つを使ってメモリを交換するっていう処理自体は普通に理解できました。  
そして、そこからshellを取る方法として  
①atollやmemcpyのgotをsystemに書き換えてreadで/bin/shを渡してshell奪取  
②.fini\_arrayを利用してなんやかんや  
③\_\_IO\_jump\_tを利用してなんやかんや  
④exitの第一引数にコードレベルで0を渡しているのでexitのgotをreadに書き換えてstdinからBOF  
の4つが（かなり悩んだ末）思いつきました。  
しかし、いずれも問題があり、挫折に終わりました。  
①はsystemのアドレスを知るためにlibc\_baseのリークが必要ということに気付き、  
それはまぁatollかmemcpyをputsに変えてやってreadでgotをリークしてオフセット計算すればいいかなと思ったのですが、  
atollかmemcpyのどちらかを変更してしまうと二度目の交換が不可能になってしまうということに気付き、断念しました。  
②と③については、何に書き換えればいいのかがわからないまま終わりました。  
そもそも.fini\_arrayを書き換えるならexitのgotとかを書き換えても同じことだし、  
③に限ってはIO\_file\_xputsを見つけることができませんでした。（32bitならわかるんだけどなぁ）  
④は、閃いた時は「これはいける！」と思ったのですが、  
直前のputsのせいでrsi（第二引数）がlibcがマッピングされている部分になってしまい、  
結局BOFしても意味が無いということが判明しました。  
それを防ぐために関数終了後にrsiがstackアドレスになる何らかの関数とputsを交換しようとしました。  
探してみたところ、readがそうだったのですが、readが取得した文字列を保存する先が0x0になってしまうため、断念しました。  
解法を早く知りたいです。  
  
simple noteは、つい最近入門したばかりのヒープ問（多分）（違ったらびっくり）だったので、とてもワクワクしながらやっていました。  
処理はすぐに理解出来た気がします。  
まずは、とりあえず知っている限りで確認できることは確認しようとしました。  
最初に、ヒープオーバーフローがあるかどうか確認しました。ありませんでした。  
次に、Unlink Attackができるかどうか確認しようとしました。ヒープオーバーフローが無かったのでそもそも無理でした。  
最後に、Use After Freeが可能かどうか確認しました。これに関しては経験がとても浅いのでよくわかりませんでしたが、  
見た感じきちんとポインターに0が代入されていましたし、そもそもデータにはオブジェクトも仮想関数テーブルも何も無かったので、  
Use After Freeができても意味あるのかな、とも少し思っていました。  
（今考えてみれば自分で書き込んでそれっぽいのを作るのかな？とも思います）  
これも、解法をしっかりと理解して、Use After Freeについての理解を今回のこの問題で深めようと思いました。  

